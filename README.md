
# آزمایش چهارم
## سوال ۱

<p dir="rtl"  style='text-align: right;'>
با اجرای برنامه در ابتدا مشکل در اندازه هیپ پیش می‌آمد،
در نتیجه قسمتی از کد یک حلقه ۱۰۰۰۰تایی داریم را تغییر داده‌ایم و به ۵۰۰۰ کاهش داده‌ایم.
سپس برنامه را با ورودی‌های زیر اجرا کرده‌ایم. خروجی برنامه هم در تصویر زیر پیدا است:
</p>

![image](images/1.png)

<p dir="rtl"  style='text-align: right;'>
در تصویر زیر نیز می‌توان میزان زمان مصرفی توابع مختلف را مشاهده کرد:
</p>

![image](images/2.png)

<p dir="rtl"  style='text-align: right;'>
 همانطور که مشاهده می‌شود بیشترین زمان بعد از تابع main
توسط تابع temp استفاده شده‌است که کد آن را می‌توان در زیر مشاهده کرد: (همچنین بعد از آن بیشترین زمان مصرفی برای کار با scanner و دریافت ورودی بوده است.)
</p>

![image](images/3.png)

<p dir="rtl"  style='text-align: right;'>
همانطور که مشاهده می‌شود این تابع شامل یک for تو در تو می‌شود که در هر تکرار یک عضو به آرایه a اضافه می‌کند،
 که همین قسمت در حالت اولیه باعث پر شدن حافظه heap می‌شده. همچنین این for تو در تو باعث می‌شود که زمان زیادی از اجرای
 کد صرف اجرای این تابع شود. با توجه به تصویر قبل ۳۹٪ زمان اجرا صرف اضافه شدن اعضای جدید به آرایه a می‌شود.
</p>


<p dir="rtl"  style='text-align: right;'>
میزان مصرف CPU:
</p>

![image](images/10.png)


<p dir="rtl"  style='text-align: right;'>
میزان مصرف Memory:
</p>

![image](images/11.png)


## سوال ۲

<p dir="rtl"  style='text-align: right;'>
در این قسمت یک کد برای محاسبه عضو nام از دنباله فیبوناچی نوشته‌ایم.
در ابتدا این‌کار را به صورت بازگشتی انجام می‌دهیم. تصویر اجرا و خروجی را می‌توانیم در زیر مشاهده کنیم:
</p>

![image](images/5.png)

<p dir="rtl"  style='text-align: right;'>
 زمان اجرای توابع مختلف آن را نیز می‌توانیم در تصویر زیر مشاهده کنیم:
</p>

![image](images/4.png)

<p dir="rtl"  style='text-align: right;'>
قطعه کد بازگشتی این قسمت را می‌توان در تصویر زیر مشاهده کرد. زمان اجرای این قطعه کد 
O(2^n) است 
و همانطور که انتظار می‌رود زمان اجرای آن در nهای بسیار بزرگ می‌شود، و مطابق انتظار همانطور
 که در تصویر قبل قابل مشاهده‌است ۹۹٪ زمان اجرای برنامه صرف اجرای این تابع می‌شود.
</p>

![image](images/6.png)

<p dir="rtl"  style='text-align: right;'>
میزان مصرف CPU:
</p>

![image](images/12.png)


<p dir="rtl"  style='text-align: right;'>
میزان مصرف Memory:
</p>

![image](images/13.png)



<p dir="rtl"  style='text-align: right;'>
حال تابع بازگشتی فیبوناچی را به iterative تغییر می‌دهیم. کد این قسمت را نیز می‌توان در تصویر زیر مشاهده کرد.
همچنین زمان اجرای این قطعه کد از O(n) است، که انتظار می‌رود در مقایسه در با کد قبلی بسیار سریعتر عمل کند:
</p>

![image](images/7.png)

<p dir="rtl"  style='text-align: right;'>
اجرای کد و خروجی کد را نیز می‌توان در تصویر زیر مشاهده کرد:
 (برای اینکه زمان اجرا طولانی تر شود عضو بزرگتری از دنباله فیبوناچی در این حالت انتخاب شده‌است.)
</p>

![image](images/8.png)

<p dir="rtl"  style='text-align: right;'>
در این قسمت نیز می‌توان زمان اجرای توابع مختلف را مشاهده کرد.
همانطور که مشاهده می‌شود با اینکه ورودی این تابع خیلی از حالت قبل بیشتر است اما زمان اجرای
 این تابع بسیار کمتر از حالت قبل است و فقط ۵۹٪ از زمان اجرا را این تابع استفاده می‌کند.
</p>

![image](images/9.png)


<p dir="rtl"  style='text-align: right;'>
میزان مصرف CPU:
</p>

![image](images/14.png)


<p dir="rtl"  style='text-align: right;'>
میزان مصرف Memory:
</p>

![image](images/15.png)


